// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Color } from '../../game/sample/color.js';
import { Equipment, unionToEquipment, unionListToEquipment } from '../../game/sample/equipment.js';
import { Vec3 } from '../../game/sample/vec3.js';
import { Weapon } from '../../game/sample/weapon.js';


export class Monster {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Monster {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMonster(bb:flatbuffers.ByteBuffer, obj?:Monster):Monster {
  return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMonster(bb:flatbuffers.ByteBuffer, obj?:Monster):Monster {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Monster()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

pos(obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new Vec3()).__init(this.bb_pos + offset, this.bb!) : null;
}

hp():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 100;
}

mana():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt16(this.bb_pos + offset) : 150;
}

color():Color {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Color.Blue;
}

weapons(index: number, obj?:Weapon):Weapon|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new Weapon()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

weaponsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

equippedType():Equipment {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readUint8(this.bb_pos + offset) : Equipment.NONE;
}

equipped<T extends flatbuffers.Table>(obj:any):any|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
}

path(index: number, obj?:Vec3):Vec3|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? (obj || new Vec3()).__init(this.bb!.__vector(this.bb_pos + offset) + index * 12, this.bb!) : null;
}

pathLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startMonster(builder:flatbuffers.Builder) {
  builder.startObject(9);
}

static addPos(builder:flatbuffers.Builder, posOffset:flatbuffers.Offset) {
  builder.addFieldStruct(0, posOffset, 0);
}

static addHp(builder:flatbuffers.Builder, hp:number) {
  builder.addFieldInt16(1, hp, 100);
}

static addMana(builder:flatbuffers.Builder, mana:number) {
  builder.addFieldInt16(2, mana, 150);
}

static addColor(builder:flatbuffers.Builder, color:Color) {
  builder.addFieldInt8(3, color, Color.Blue);
}

static addWeapons(builder:flatbuffers.Builder, weaponsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, weaponsOffset, 0);
}

static createWeaponsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startWeaponsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEquippedType(builder:flatbuffers.Builder, equippedType:Equipment) {
  builder.addFieldInt8(6, equippedType, Equipment.NONE);
}

static addEquipped(builder:flatbuffers.Builder, equippedOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, equippedOffset, 0);
}

static addPath(builder:flatbuffers.Builder, pathOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, pathOffset, 0);
}

static startPathVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(12, numElems, 4);
}

static endMonster(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishMonsterBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
}

static finishSizePrefixedMonsterBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
}

static createMonster(builder:flatbuffers.Builder, posOffset:flatbuffers.Offset, hp:number, mana:number, color:Color, weaponsOffset:flatbuffers.Offset, equippedType:Equipment, equippedOffset:flatbuffers.Offset, pathOffset:flatbuffers.Offset):flatbuffers.Offset {
  Monster.startMonster(builder);
  Monster.addPos(builder, posOffset);
  Monster.addHp(builder, hp);
  Monster.addMana(builder, mana);
  Monster.addColor(builder, color);
  Monster.addWeapons(builder, weaponsOffset);
  Monster.addEquippedType(builder, equippedType);
  Monster.addEquipped(builder, equippedOffset);
  Monster.addPath(builder, pathOffset);
  return Monster.endMonster(builder);
}
}
